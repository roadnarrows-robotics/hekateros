#! /usr/bin/env python
 
###############################################################################
#
# Package:  RoadNarrows Robotics Hekateros Robotic Manipulator Package
#
# Link:     https://github.com/roadnarrows-robotics/hekateros
#
# ROS Node: move
#
# File: move
#
## \file 
##
## $LastChangedDate$
## $Rev$
##
## \brief Record or play back a set of moves.
##
## Note that this node uses the Hekateros service interface which is different
## from the follow trajectory actionlib server interface. 
##
## The format of the input/output file is yaml.
##
## \author Robin Knight (robin.knight@roadnarrows.com)
##  
## \par Copyright:
##   (C) 2015.  RoadNarrows LLC.\n
##   (http://www.roadnarrows.com)\n
##   All Rights Reserved
##
# @EulaBegin@
# @EulaEnd@
#
###############################################################################

import sys
import os
import time
import fcntl
import termios
import getopt

import yaml

import roslib; roslib.load_manifest('hekateros_control')
import rospy

from industrial_msgs.msg import RobotMode
from industrial_msgs.msg import TriState

from hekateros_control.msg import HekRobotStatusExtended
from hekateros_control.msg import HekJointStateExtended
from hekateros_control.msg import ServoHealth
from hekateros_control.msg import HekOpState
from hekateros_control.srv import Freeze
from hekateros_control.srv import Release

# Application exit codes
APP_EC_OK   = 0   # success 
APP_EC_ARGS = 2   # invalid command-line options and/or arguments
APP_EC_EXEC = 4   # execution failure

# Progress characters
ProgressChars = ['|', '/', '|', '\\']


# ------------------------------------------------------------------------------
# Exception Class usage
# ------------------------------------------------------------------------------

##
## \brief Unit test command-line exception class.
##
## Raise usage excpetion.
##
class usage(Exception):

  ##
  ## \brief Constructor.
  ##
  ## \param msg   Error message string.
  ##
  def __init__(self, msg):
    ## error message attribute
    self.msg = msg


# ------------------------------------------------------------------------------
# Class application
# ------------------------------------------------------------------------------

##
## \brief Hekateros Trajectory.
##
class application():

  #
  ## \brief Constructor.
  #
  def __init__(self):
    self._Argv0 = os.path.basename(__file__)
    self.m_win = None # future gui version

  #
  ## \brief Print usage error.
  ##
  ## \param emsg  Error message string.
  #
  def printUsageErr(self, emsg):
    if emsg:
      print "%s: %s" % (self._Argv0, emsg)
    else:
      print "%s: error" % (self._Argv0)
    print "Try '%s --help' for more information." % (self._Argv0)

  ## \brief Print Command-Line Usage Message.
  def printUsage(self):
    print \
"""
usage: %s [OPTIONS] record FILE
       %s [OPTIONS] play FILE
       %s --help

Read and parse a list of trajectory files, requesting Hekateros to follow each
parsed trajectory in sequence.

Options and arguments:
-a, --auto          : Automatically play through the list of moves.
                        Default: Manually step through moves.
-l, --loop          : Continuously play through list of moves.
                        Default: Play list only once.
-t, --time=T        : If auto, then this is the pause time between moves.
                        Default: 1.0 second.
-v, --velocity=V    : Velocity in degrees/second of all joints during a move.
                        Default: 50.0 degrees/second.
           
-h, --help          : Display this help and exit.

Description:
For recording, the current Hekateros position is read and any moved joints
are saved as the next goal position with the given velocity V. 
The pause time T is appended to FILE after each recorded move.

Record controls:
  'r' | ' ' (space) - Record position.
  'q'               - Quit recording. FILE will be closed and this application
                      exits.

For play, the list of moves in FILE is played back, Each move is executed by
the Hekateros. After the move, play waits for the allotted pause time T (if
auto) or for user keyboard input.

Play controls:
  'p' | ' ' (space) - Next move (ignored if auto).
  'q'               - Quit playback.
"""  % (self._Argv0, self._Argv0, self._Argv0)
 
  #
  ## \brief Get command-line options
  ##  
  ## \param argv          Argument list. If not None, then overrides
  ##                      command-line arguments.
  ## \param [out] kwargs  Keyword argument list.  
  ##
  ## \return Parsed keyword arguments.
  #
  def getOptions(self, argv=None, **kwargs):
    if argv is None:
      argv = sys.argv

    self._Argv0 = os.path.basename(kwargs.get('argv0', __file__))

    # defaults
    kwargs['debug']     = False
    kwargs['auto']      = False
    kwargs['loop']      = False
    kwargs['time']      = 1.0
    kwargs['velocity']  = 50.0

    # parse command-line options
    try:
      opts, args = getopt.getopt(argv[1:], "alt:v:?h",
          ['auto', 'loop', 'time=', 'velocity=', 'help', ''])
    except getopt.error, msg:
      raise usage(msg)
    for opt, optarg in opts:
      if opt in ('-h', '--help', '-?'):
        self.printUsage()
        sys.exit(APP_EC_OK)
      elif opt in ('-a', '--auto'):
        kwargs['auto'] = True
      elif opt in ('-l', '--loop'):
        kwargs['loop'] = True
      elif opt in ('-t', '--time'):
        try:
          kwargs['time'] = float(optarg)
        except ValueError:
          self.printUsageErr("--time=%s: Not a float." % (optarg))
          sys.exit(APP_EC_ARGS)
      elif opt in ('-v', '--velocity'):
        try:
          kwargs['velocity'] = float(optarg)
        except ValueError:
          self.printUsageErr("--velocity=%s: Not a float." % (optarg))
          sys.exit(APP_EC_ARGS)

    if len(args) < 1:
      self.printUsageErr("No record/play operator specified.")
      sys.exit(APP_EC_ARGS)
    elif args[0] not in ('record', 'play'):
      self.printUsageErr("%s: Invalid record/play operator.")
      sys.exit(APP_EC_ARGS)
    else:
      kwargs['op'] = args[0]
    if len(args) < 2:
      self.printUsageErr("No FILE specified.")
      sys.exit(APP_EC_ARGS)
    else:
      kwargs['filename'] = args[1]

    return kwargs

  #
  ## \brief Block waiting for any keyboard key press.
  ##    
  ## \return Return pressed keyboard code.
  #
  def kbhit(self):
    fd = sys.stdin.fileno()
    oldattr = termios.tcgetattr(fd)
    newattr = termios.tcgetattr(fd)
    newattr[3] = newattr[3] & ~termios.ICANON & ~termios.ECHO
    termios.tcsetattr(fd, termios.TCSANOW, newattr)
    oldflags = fcntl.fcntl(fd, fcntl.F_GETFL)
    fcntl.fcntl(fd, fcntl.F_SETFL, oldflags | os.O_NONBLOCK)
    try:
      while True:
        try:
          c = sys.stdin.read(1)
          #print 'here', repr(c)
          break
        except IOError:
          pass
    finally:
      termios.tcsetattr(fd, termios.TCSAFLUSH, oldattr)
      fcntl.fcntl(fd, fcntl.F_SETFL, oldflags)
    return c

  #
  ## \brief Show ascii progress bar.
  ##    
  ## \param index Progress index.
  #
  def show_progress_bar(self, index):
    self.pr("%s\r" % (ProgressChars[index]))

  #
  ## \brief Print text to stdout and flush.
  ##    
  ## Output file stream stdout is usually line buffered. To force display
  ## of text with no newlines, flush after writing.
  ##
  ## \param text  Text string to print.
  #
  def pr(self, text):
    sys.stdout.write(text)
    sys.stdout.flush()

  #
  ## \brief Load trajectory from file.
  ##
  ## The file is opened, parsed, and loaded into a structured document.
  ##    
  ## \param filename  Name of file specifying trajectory.
  ##
  ## \return True on success, False on failure.
  #
  def loadMoves(self, filename):
    try:
      stream = open(filename, 'r')
    except IOError, e:
      print "%s:" % (self._Argv0), e
      return False
    try:
      self.m_doc = yaml.load(stream)
    except yaml.scanner.ScannerError, e:
      print "%s: YAML:" % (self._Argv0), e
      return False
    finally:
      stream.close()
    self.m_docMoves = self.m_doc['moves']
    #print self.m_docTraj['joint_names']
    #print len(self.m_docTraj['points'])
    return True

  #
  ## \brief Make a ROS goal trajectory message from the loaded document.
  #
  def makeMoveMsg(self):
    joint_traj = trajectory_msgs.msg.JointTrajectory()
    joint_traj.joint_names = self.m_docTraj['joint_names']
    for point in self.m_docTraj['points']:
      jtp = trajectory_msgs.msg.JointTrajectoryPoint()
      jtp.positions = point['positions']
      jtp.velocities = point['velocities']
      jtp.accelerations = point['accelerations']
      joint_traj.points.append(jtp)
    self.m_goal = control_msgs.msg.FollowJointTrajectoryGoal()
    self.m_goal.trajectory = joint_traj
    self.m_goal.trajectory.header.stamp = rospy.Time.now() + \
                                          rospy.Duration(10.0)
    print "  Joints:   ", self.m_goal.trajectory.joint_names
    print "  Waypoints:", len(self.m_goal.trajectory.points)

  #
  ## \brief Execute Hekateros trajectory.
  ##    
  ## The execution is performed through the actionlib follow trajectory
  ## interaction of the client(this) and Hekateros (hekateros_control) nodes.
  ##
  ## \return True on success, False on failure.
  #
  def execMove(self):
    msg = "  Executiong trajectory ..."
    # Send the goal to the action server.
    self.pr(msg+"\r")
    self.m_client.send_goal(self.m_goal)

    i = 0

    #
    # Track progress.
    #
    while True:
      state = self.m_client.get_state()
      if state == GoalStatus.PENDING or \
         state == GoalStatus.ACTIVE:
        self.show_progress_bar(i)
        i = (i+1) % len(ProgressChars)
      elif state == GoalStatus.SUCCEEDED:
        if self.m_client.get_result() < 0:
          print msg, "failed."
          return False
        else:
          print msg, "done."
          return True
      else:
        print msg, "failed."
        return False
      time.sleep(0.25)

    # Waits for the server to finish performing the action.
    # block wait alternative self.m_client.wait_for_result()

  def record():
    try:
      self.m_stream = open(self.kwargs['filename'], 'w')
    except IOError, e:
      print "%s:" % (self._Argv0), e
      return False

    self.m_doc = {}
    loop on user input
      add to yaml doc
    save close file

  def play():
    if not self.loadMoves(self.kwargs['filename']):
      return False

    cycle = 1

    #
    # Cycle through loop of trajectory files.
    #
    while kwargs['loop'] or cycle == 1:
      if kwargs['loop']:
        print "\n\n  * Cycle %d *" % (cycle)

      n = 1

      #
      # Loop through all trajectory files.
      #
      for filename in kwargs['filenames']:
        print "Move %d" % (n)
        if not self.loadTrajectory(filename):
          return APP_EC_EXEC
        self.makeGoalMsg()
        if not kwargs['auto']:
          self.pr("PRESS ANY KEY...")
          self.kbhit()
          self.pr("\r                  \r") # erase prompt
        if not self.execTrajectory():
          return APP_EC_EXEC
        n += 1

      cycle += 1

    return APP_EC_OK


  #
  ## \brief Run application.
  ##    
  ## \param argv    Optional argument list to override command-line arguments.
  ## \param kwargs  Optional keyword argument list.
  ##
  ## \return Exit code.
  #
  def run(self, argv=None, **kwargs):
  
    # parse command-line options and arguments
    try:
      kwargs = self.getOptions(argv, **kwargs)
    except usage, e:
      self.printUsageErr(e.msg)
      return APP_EC_ARGS

    try:
      # initialize ROS node
      rospy.init_node('move')

      # subscribe to extended robot status data
      rospy.Subscriber("hekateros_control/robot_status_ex", 
                      HekRobotStatusExtended, 
                      self.m_win.updateRobotStatus) 

      # subscribe to extended joint state data
      rospy.Subscriber("hekateros_control/joint_states_ex", 
                        HekJointStateExtended, 
                        self.updateJointStates) 

      # publish trajectory to hekateros controller
      self.m_joint_cmd_pub = rospy.Publisher(
          "hekateros_control/joint_command",
          trajectory_msgs.msg.JointTrajectory)

      print "Hekateros interface initialized."

    if kwargs['op'] == 'record':
      return self.record()
    elif kwargs['op'] == 'play':
      return self.play()
    else:
      print "BUG: %s: unknown operator.")
      return APP_EC_ARGS



# ------------------------------------------------------------------------------
# main
# ------------------------------------------------------------------------------
if __name__ == '__main__':
  app = application();
  sys.exit( app.run() );
